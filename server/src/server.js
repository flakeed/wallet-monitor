const express = require('express');
const cors = require('cors');
const { Connection, PublicKey } = require('@solana/web3.js');
const Redis = require('ioredis');
require('dotenv').config();

const OptimizedSolanaWebSocketService = require('./services/optimizedSolanaWebSocketService');
const Database = require('./database/connection');

const app = express();
const port = process.env.PORT || 5001;

app.use(cors({
    origin: ['http://localhost:3000', 'http://localhost:3001', 'https://wallet-monitor-client.vercel.app'],
    optionsSuccessStatus: 200,
}));
app.use(express.json());

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤
const solanaService = new OptimizedSolanaWebSocketService();
const db = new Database();
const redis = new Redis(process.env.REDIS_URL || 'redis://default:CwBXeFAGuARpNfwwziJyFttVApFFFyGD@switchback.proxy.rlwy.net:25212');

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è SSE –∫–ª–∏–µ–Ω—Ç–æ–≤
const sseClients = new Set();

// –ó–∞–ø—É—Å–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
(async () => {
    try {
        await solanaService.start();
        console.log('üöÄ Optimized Solana WebSocket service started');
    } catch (error) {
        console.error('‚ùå Failed to start Solana service:', error.message);
        // Retry after 5 seconds
        setTimeout(async () => {
            try {
                await solanaService.start();
            } catch (e) {
                console.error('‚ùå Retry failed:', e.message);
            }
        }, 5000);
    }
})();

// ============ REAL-TIME ENDPOINTS ============

// Server-Sent Events –¥–ª—è real-time –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
app.get('/api/transactions/stream', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'Cache-Control');
    
    res.flushHeaders();
    
    // –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
    const subscriber = new Redis(process.env.REDIS_URL || 'redis://default:CwBXeFAGuARpNfwwziJyFttVApFFFyGD@switchback.proxy.rlwy.net:25212');
    
    subscriber.subscribe('transactions', (err, count) => {
        if (err) {
            console.error('‚ùå Redis subscription error:', err.message);
            res.status(500).end();
            return;
        }
        console.log(`‚úÖ New SSE client connected (${count} total subscriptions)`);
        sseClients.add(res);
    });
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
    subscriber.on('message', (channel, message) => {
        if (channel === 'transactions' && res.writable) {
            try {
                const data = JSON.parse(message);
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                res.write(`event: transaction\n`);
                res.write(`data: ${JSON.stringify({
                    type: 'new_transaction',
                    transaction: data,
                    timestamp: new Date().toISOString()
                })}\n\n`);
                
                console.log(`üì° SSE: Sent transaction ${data.signature} to client`);
            } catch (error) {
                console.error('‚ùå Error sending SSE message:', error.message);
            }
        }
    });
    
    // Keep-alive –ø–∏–Ω–≥ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
    const keepAlive = setInterval(() => {
        if (res.writable) {
            res.write(`: keep-alive ${Date.now()}\n\n`);
        } else {
            clearInterval(keepAlive);
        }
    }, 30000);
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    res.write(`event: connected\n`);
    res.write(`data: ${JSON.stringify({
        type: 'connection_established',
        timestamp: new Date().toISOString(),
        server_time: Date.now()
    })}\n\n`);
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞
    req.on('close', () => {
        console.log('üîå SSE client disconnected');
        clearInterval(keepAlive);
        subscriber.unsubscribe();
        subscriber.quit();
        sseClients.delete(res);
        res.end();
    });
    
    req.on('error', (error) => {
        console.error('‚ùå SSE client error:', error.message);
        clearInterval(keepAlive);
        subscriber.quit();
        sseClients.delete(res);
    });
});

// WebSocket —Å—Ç–∞—Ç—É—Å –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
app.get('/api/status/realtime', (req, res) => {
    const status = solanaService.getStatus();
    const serverStats = {
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        activeSSEClients: sseClients.size,
        serverTime: Date.now()
    };
    
    res.json({
        solana: status,
        server: serverStats,
        redis: {
            connected: redis.status === 'ready'
        }
    });
});

// ============ WALLET MANAGEMENT ============

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–æ—à–µ–ª—å–∫–∏ —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
app.get('/api/wallets', async (req, res) => {
    try {
        const wallets = await db.getActiveWallets();
        
        // –ë—ã—Å—Ç—Ä–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–∑ –∫–µ—à–∞ –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
        const walletsWithStats = await Promise.all(
            wallets.map(async (wallet) => {
                try {
                    // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫–µ—à–∞
                    const cachedStats = await redis.get(`wallet_stats:${wallet.address}`);
                    if (cachedStats) {
                        return {
                            ...wallet,
                            stats: JSON.parse(cachedStats)
                        };
                    }
                    
                    // –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–µ—à–µ, –ø–æ–ª—É—á–∞–µ–º –∏–∑ –ë–î
                    const stats = await db.getWalletStats(wallet.id);
                    const formattedStats = {
                        totalBuyTransactions: stats.total_buy_transactions || 0,
                        totalSellTransactions: stats.total_sell_transactions || 0,
                        totalTransactions: (stats.total_buy_transactions || 0) + (stats.total_sell_transactions || 0),
                        totalSpentSOL: Number(stats.total_sol_spent || 0).toFixed(6),
                        totalReceivedSOL: Number(stats.total_sol_received || 0).toFixed(6),
                        totalSpentUSD: Number(stats.total_usd_spent || 0).toFixed(2),
                        totalReceivedUSD: Number(stats.total_usd_received || 0).toFixed(2),
                        netSOL: (Number(stats.total_sol_received || 0) - Number(stats.total_sol_spent || 0)).toFixed(6),
                        netUSD: (Number(stats.total_usd_received || 0) - Number(stats.total_usd_spent || 0)).toFixed(2),
                        lastTransactionAt: stats.last_transaction_at,
                    };
                    
                    // –ö–µ—à–∏—Ä—É–µ–º –Ω–∞ 30 —Å–µ–∫—É–Ω–¥
                    await redis.setex(`wallet_stats:${wallet.address}`, 30, JSON.stringify(formattedStats));
                    
                    return {
                        ...wallet,
                        stats: formattedStats
                    };
                } catch (error) {
                    console.error(`‚ùå Error getting stats for wallet ${wallet.address}:`, error.message);
                    return {
                        ...wallet,
                        stats: {
                            totalBuyTransactions: 0,
                            totalSellTransactions: 0,
                            totalTransactions: 0,
                            totalSpentSOL: '0.000000',
                            totalReceivedSOL: '0.000000',
                            totalSpentUSD: '0.00',
                            totalReceivedUSD: '0.00',
                            netSOL: '0.000000',
                            netUSD: '0.00',
                            lastTransactionAt: null,
                        }
                    };
                }
            })
        );
        
        res.json(walletsWithStats);
    } catch (error) {
        console.error('‚ùå Error fetching wallets:', error.message);
        res.status(500).json({ error: 'Failed to fetch wallets' });
    }
});

// –î–æ–±–∞–≤–∏—Ç—å –∫–æ—à–µ–ª–µ–∫ (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ)
app.post('/api/wallets', async (req, res) => {
    try {
        const { address, name } = req.body;
        
        if (!address) {
            return res.status(400).json({ error: 'Wallet address is required' });
        }
        
        // –ë—ã—Å—Ç—Ä–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞
        if (address.length !== 44 || !/^[1-9A-HJ-NP-Za-km-z]+$/.test(address)) {
            return res.status(400).json({ error: 'Invalid Solana wallet address format' });
        }
        
        const wallet = await solanaService.addWallet(address, name);
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º SSE –∫–ª–∏–µ–Ω—Ç–æ–≤ –æ –Ω–æ–≤–æ–º –∫–æ—à–µ–ª—å–∫–µ
        const notification = {
            type: 'wallet_added',
            wallet: {
                ...wallet,
                stats: {
                    totalBuyTransactions: 0,
                    totalSellTransactions: 0,
                    totalTransactions: 0,
                    totalSpentSOL: '0.000000',
                    totalReceivedSOL: '0.000000',
                    totalSpentUSD: '0.00',
                    totalReceivedUSD: '0.00',
                    netSOL: '0.000000',
                    netUSD: '0.00',
                    lastTransactionAt: null,
                }
            },
            timestamp: new Date().toISOString()
        };
        
        await redis.publish('wallets', JSON.stringify(notification));
        
        res.json({
            success: true,
            wallet,
            message: 'Wallet added and monitoring started'
        });
    } catch (error) {
        console.error('‚ùå Error adding wallet:', error.message);
        if (error.message.includes('already exists')) {
            res.status(409).json({ error: 'Wallet is already being monitored' });
        } else {
            res.status(500).json({ error: error.message });
        }
    }
});

// –£–¥–∞–ª–∏—Ç—å –∫–æ—à–µ–ª–µ–∫ (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ)
app.delete('/api/wallets/:address', async (req, res) => {
    try {
        const address = req.params.address.trim();
        
        if (!address || address.length !== 44 || !/^[1-9A-HJ-NP-Za-km-z]+$/.test(address)) {
            return res.status(400).json({ error: 'Invalid Solana wallet address format' });
        }
        
        await solanaService.removeWallet(address);
        
        // –û—á–∏—â–∞–µ–º –∫–µ—à —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        await redis.del(`wallet_stats:${address}`);
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º SSE –∫–ª–∏–µ–Ω—Ç–æ–≤ –æ–± —É–¥–∞–ª–µ–Ω–∏–∏
        const notification = {
            type: 'wallet_removed',
            address,
            timestamp: new Date().toISOString()
        };
        
        await redis.publish('wallets', JSON.stringify(notification));
        
        res.json({
            success: true,
            message: 'Wallet removed and monitoring stopped'
        });
    } catch (error) {
        console.error('‚ùå Error removing wallet:', error.message);
        if (error.message.includes('not found')) {
            res.status(404).json({ error: 'Wallet not found in monitoring list' });
        } else {
            res.status(500).json({ error: 'Failed to remove wallet' });
        }
    }
});

// ============ TRANSACTION DATA ============

// –ü–æ–ª—É—á–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º)
app.get('/api/transactions', async (req, res) => {
    try {
        const hours = parseInt(req.query.hours) || 24;
        const limit = parseInt(req.query.limit) || 50;
        const type = req.query.type;
        
        // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫–µ—à–∞
        const cacheKey = `transactions:${hours}:${limit}:${type || 'all'}`;
        const cached = await redis.get(cacheKey);
        
        if (cached) {
            console.log(`‚ö° Cache hit for transactions: ${cacheKey}`);
            return res.json(JSON.parse(cached));
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –∏–∑ –ë–î
        const transactions = await db.getRecentTransactions(hours, limit, type);
        const groupedTransactions = {};
        
        transactions.forEach((row) => {
            if (!groupedTransactions[row.signature]) {
                groupedTransactions[row.signature] = {
                    signature: row.signature,
                    time: row.block_time,
                    transactionType: row.transaction_type,
                    solSpent: row.sol_spent ? Number(row.sol_spent).toFixed(6) : null,
                    solReceived: row.sol_received ? Number(row.sol_received).toFixed(6) : null,
                    usdSpent: row.usd_spent ? Number(row.usd_spent).toFixed(2) : null,
                    usdReceived: row.usd_received ? Number(row.usd_received).toFixed(2) : null,
                    wallet: {
                        address: row.wallet_address,
                        name: row.wallet_name,
                    },
                    tokensBought: [],
                    tokensSold: [],
                };
            }
            
            if (row.mint) {
                const tokenData = {
                    mint: row.mint,
                    symbol: row.symbol,
                    name: row.token_name,
                    logoURI: row.logo_uri,
                    amount: Number(row.token_amount),
                    decimals: row.decimals || 6,
                };
                
                if (row.operation_type === 'buy') {
                    groupedTransactions[row.signature].tokensBought.push(tokenData);
                } else if (row.operation_type === 'sell') {
                    groupedTransactions[row.signature].tokensSold.push(tokenData);
                }
            }
        });
        
        const result = Object.values(groupedTransactions);
        
        // –ö–µ—à–∏—Ä—É–µ–º –Ω–∞ 10 —Å–µ–∫—É–Ω–¥
        await redis.setex(cacheKey, 10, JSON.stringify(result));
        
        res.json(result);
    } catch (error) {
        console.error('‚ùå Error fetching transactions:', error.message);
        res.status(500).json({ error: 'Failed to fetch transactions' });
    }
});

// ============ STATISTICS ============

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π (—Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º)
app.get('/api/stats/transactions', async (req, res) => {
    try {
        const hours = parseInt(req.query.hours) || 24;
        const cacheKey = `transaction_stats:${hours}`;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
        const cached = await redis.get(cacheKey);
        if (cached) {
            console.log(`‚ö° Cache hit for transaction stats: ${cacheKey}`);
            return res.json(JSON.parse(cached));
        }
        
        const stats = await db.getMonitoringStats();
        
        const result = {
            buyTransactions: stats.buy_transactions_today || 0,
            sellTransactions: stats.sell_transactions_today || 0,
            totalTransactions: (stats.buy_transactions_today || 0) + (stats.sell_transactions_today || 0),
            solSpent: Number(stats.sol_spent_today || 0).toFixed(6),
            solReceived: Number(stats.sol_received_today || 0).toFixed(6),
            usdSpent: Number(stats.usd_spent_today || 0).toFixed(2),
            usdReceived: Number(stats.usd_received_today || 0).toFixed(2),
            netSOL: (Number(stats.sol_received_today || 0) - Number(stats.sol_spent_today || 0)).toFixed(6),
            netUSD: (Number(stats.usd_received_today || 0) - Number(stats.usd_spent_today || 0)).toFixed(2),
        };
        
        // –ö–µ—à–∏—Ä—É–µ–º –Ω–∞ 15 —Å–µ–∫—É–Ω–¥
        await redis.setex(cacheKey, 15, JSON.stringify(result));
        
        res.json(result);
    } catch (error) {
        console.error('‚ùå Error fetching transaction stats:', error.message);
        res.status(500).json({ error: 'Failed to fetch transaction stats' });
    }
});

// –¢–æ–ø —Ç–æ–∫–µ–Ω—ã (—Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º)
app.get('/api/stats/tokens', async (req, res) => {
    try {
        const limit = parseInt(req.query.limit) || 10;
        const type = req.query.type;
        const cacheKey = `top_tokens:${limit}:${type || 'all'}`;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
        const cached = await redis.get(cacheKey);
        if (cached) {
            console.log(`‚ö° Cache hit for top tokens: ${cacheKey}`);
            return res.json(JSON.parse(cached));
        }
        
        const topTokens = await db.getTopTokens(limit, type);
        
        // –ö–µ—à–∏—Ä—É–µ–º –Ω–∞ 30 —Å–µ–∫—É–Ω–¥
        await redis.setex(cacheKey, 30, JSON.stringify(topTokens));
        
        res.json(topTokens);
    } catch (error) {
        console.error('‚ùå Error fetching top tokens:', error.message);
        res.status(500).json({ error: 'Failed to fetch top tokens' });
    }
});

// ============ SERVICE CONTROL ============

// –°—Ç–∞—Ç—É—Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
app.get('/api/monitoring/status', (req, res) => {
    try {
        const status = solanaService.getStatus();
        res.json({
            isMonitoring: status.isConnected && status.isStarted,
            subscriptions: status.subscriptions,
            messageCount: status.stats.messagesReceived,
            transactionsProcessed: status.stats.transactionsProcessed,
            uptime: status.stats.uptime,
            queueLength: status.stats.queueLength || 0,
            lastTransaction: status.stats.lastTransaction
        });
    } catch (error) {
        console.error('‚ùå Error getting monitoring status:', error.message);
        res.status(500).json({ error: 'Failed to get monitoring status' });
    }
});

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º
app.post('/api/monitoring/toggle', async (req, res) => {
    try {
        const { action } = req.body;
        
        if (action === 'start') {
            await solanaService.start();
            res.json({ success: true, message: 'Monitoring started' });
        } else if (action === 'stop') {
            await solanaService.stop();
            res.json({ success: true, message: 'Monitoring stopped' });
        } else if (action === 'restart') {
            await solanaService.stop();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await solanaService.start();
            res.json({ success: true, message: 'Monitoring restarted' });
        } else {
            res.status(400).json({ error: 'Invalid action. Use "start", "stop", or "restart"' });
        }
    } catch (error) {
        console.error('‚ùå Error toggling monitoring:', error.message);
        res.status(500).json({ error: error.message });
    }
});

// –û—á–∏—Å—Ç–∫–∞ –∫–µ—à–µ–π
app.post('/api/cache/clear', async (req, res) => {
    try {
        const { type } = req.body;
        
        if (type === 'all') {
            await redis.flushdb();
            res.json({ success: true, message: 'All caches cleared' });
        } else if (type === 'transactions') {
            const keys = await redis.keys('transactions:*');
            if (keys.length > 0) {
                await redis.del(...keys);
            }
            res.json({ success: true, message: 'Transaction caches cleared' });
        } else if (type === 'wallets') {
            const keys = await redis.keys('wallet_stats:*');
            if (keys.length > 0) {
                await redis.del(...keys);
            }
            res.json({ success: true, message: 'Wallet caches cleared' });
        } else if (type === 'tokens') {
            const keys = await redis.keys('token:*');
            if (keys.length > 0) {
                await redis.del(...keys);
            }
            res.json({ success: true, message: 'Token caches cleared' });
        } else {
            res.status(400).json({ error: 'Invalid cache type' });
        }
    } catch (error) {
        console.error('‚ùå Error clearing cache:', error.message);
        res.status(500).json({ error: 'Failed to clear cache' });
    }
});

// ============ BULK OPERATIONS ============

// –ú–∞—Å—Å–æ–≤–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–æ–≤ (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ)
app.post('/api/wallets/bulk', async (req, res) => {
    try {
        const { wallets } = req.body;
        
        if (!wallets || !Array.isArray(wallets)) {
            return res.status(400).json({ error: 'Wallets array is required' });
        }
        
        if (wallets.length === 0) {
            return res.status(400).json({ error: 'At least one wallet is required' });
        }
        
        if (wallets.length > 50) {
            return res.status(400).json({ error: 'Maximum 50 wallets allowed per bulk import' });
        }
        
        const results = {
            total: wallets.length,
            successful: 0,
            failed: 0,
            errors: [],
            successfulWallets: [],
        };
        
        // –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö –∞–¥—Ä–µ—Å–æ–≤ —Å–Ω–∞—á–∞–ª–∞
        for (const wallet of wallets) {
            if (!wallet.address || wallet.address.length !== 44 || !/^[1-9A-HJ-NP-Za-km-z]+$/.test(wallet.address)) {
                results.failed++;
                results.errors.push({
                    address: wallet.address || 'invalid',
                    name: wallet.name || null,
                    error: 'Invalid Solana wallet address format',
                });
            }
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤–∞–ª–∏–¥–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∏
        for (const wallet of wallets) {
            const hasError = results.errors.some((error) => error.address === wallet.address);
            if (hasError) continue;
            
            try {
                const addedWallet = await solanaService.addWallet(wallet.address, wallet.name || null);
                results.successful++;
                results.successfulWallets.push({
                    address: wallet.address,
                    name: wallet.name || null,
                    id: addedWallet.id,
                });
            } catch (error) {
                results.failed++;
                results.errors.push({
                    address: wallet.address,
                    name: wallet.name || null,
                    error: error.message,
                });
            }
            
            // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –¥–æ–±–∞–≤–ª–µ–Ω–∏—è–º–∏
            await new Promise((resolve) => setTimeout(resolve, 10));
        }
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º SSE –∫–ª–∏–µ–Ω—Ç–æ–≤ –æ –º–∞—Å—Å–æ–≤–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏
        if (results.successful > 0) {
            const notification = {
                type: 'bulk_wallets_added',
                count: results.successful,
                timestamp: new Date().toISOString()
            };
            
            await redis.publish('wallets', JSON.stringify(notification));
        }
        
        res.json({
            success: true,
            message: `Bulk import completed: ${results.successful} successful, ${results.failed} failed`,
            results,
        });
    } catch (error) {
        console.error('‚ùå Error in bulk wallet import:', error.message);
        res.status(500).json({ error: 'Failed to import wallets' });
    }
});

// ============ HEALTH CHECK ============

app.get('/api/health', async (req, res) => {
    try {
        const dbHealth = await db.healthCheck();
        const solanaStatus = solanaService.getStatus();
        const redisStatus = redis.status === 'ready';
        
        const health = {
            status: 'healthy',
            timestamp: new Date().toISOString(),
            services: {
                database: dbHealth.status === 'healthy',
                solana: solanaStatus.isConnected && solanaStatus.isStarted,
                redis: redisStatus,
                server: true
            },
            stats: {
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                sseClients: sseClients.size,
                monitoredWallets: solanaStatus.subscriptions,
                processedTransactions: solanaStatus.stats.transactionsProcessed
            }
        };
        
        const allHealthy = Object.values(health.services).every(status => status === true);
        if (!allHealthy) {
            health.status = 'degraded';
        }
        
        res.json(health);
    } catch (error) {
        console.error('‚ùå Health check error:', error.message);
        res.status(500).json({
            status: 'unhealthy',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// ============ GRACEFUL SHUTDOWN ============

process.on('SIGINT', async () => {
    console.log('üõë Shutting down server gracefully...');
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º SSE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    sseClients.forEach((client) => {
        try {
            client.write('event: shutdown\ndata: {"type": "server_shutdown"}\n\n');
            client.end();
        } catch (error) {
            console.error('‚ùå Error closing SSE client:', error.message);
        }
    });
    
    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã
    try {
        await solanaService.stop();
        await redis.quit();
        await db.close();
        console.log('‚úÖ All services stopped gracefully');
    } catch (error) {
        console.error('‚ùå Error during shutdown:', error.message);
    }
    
    process.exit(0);
});

process.on('SIGTERM', async () => {
    console.log('üõë Received SIGTERM, shutting down...');
    
    sseClients.forEach((client) => client.end());
    
    try {
        await solanaService.stop();
        await redis.quit();
        await db.close();
    } catch (error) {
        console.error('‚ùå Error during shutdown:', error.message);
    }
    
    process.exit(0);
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(port, '158.220.125.26', () => {
    console.log(`üöÄ Optimized server running on http://158.220.125.26:${port}`);
    console.log(`üì° Real-time transaction monitoring: Active`);
    console.log(`‚ö° SSE endpoint: /api/transactions/stream`);
    console.log(`üìä Health check: /api/health`);
});